포인터는 메모리 주소를 저장하는 변수로, 주로 다른 변수의 주소를 저장하고 해당 주소에 접근하여 값을 변경하거나 읽는 데 사용됩니다. 아래는 C 언어에서 포인터에 대한 몇 가지 주요한 점들에 대한 설명입니다.

int *ptr;
포인터는 변수의 주소를 저장하는 변수입니다. 정수, 문자 또는 다른 데이터 타입의 주소를 저장할 수 있습니다.
포인터 변수를 선언할 때에는 데이터 타입 뒤에 *를 사용합니다. 예를 들어, int 형 변수의 주소를 저장하는 포인터는 다음과 같이 선언됩니다.

int x = 10;
int *ptr = &x; 
포인터는 반드시 초기화되어야 합니다. 초기화하지 않은 포인터를 사용하면 예측할 수 없는 동작이 발생할 수 있습니다.
포인터를 변수의 주소로 초기화하려면 다음과 같이 합니다.

int y = *ptr; 
*ptr = 20;    
포인터를 사용하여 해당 주소에 저장된 값을 가져오거나 변경할 수 있습니다.

int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr; 
ptr++;          
포인터에 산술 연산을 수행할 수 있습니다. 주로 배열에서의 포인터 연산이 유용하게 사용됩니다.
========================================================

01 #include <stdio.h>
02
03 int strleng(char *ch);
04 int main(void) 
05 {
06    int len;
07     char str[ ] = "c language and data structure";
08    len = strleng(str);
09    printf("문자열의 크기는 %d다.\n", len); 
10     return 0;
11 }
12
13 int strleng(char *ch) 
14 {
15    int index;
16     for(index = 0; *(ch+index) != '\0'; index+ +);
17
18     return index; 
19 }
______________________________________________________________
03 int strleng(char *ch);
strleng이라는 함수의 프로토타입을 선언합니다. 이 함수는 문자열의 길이를 계산하여 반환합니다. 함수는 문자열을 나타내는 포인터를 매개변수로 받습니다.

05 {
06    int len;
07     char str[ ] = "c language and data structure";
08    len = strleng(str);
09    printf("문자열의 크기는 %d다.\n", len); 
10     return 0;
11 }
main 함수가 시작됩니다.
char str[]는 초기화된 문자열을 저장하는 문자 배열을 선언합니다.
len 변수는 strleng 함수를 호출하여 반환된 문자열의 길이를 저장합니다.
printf 함수를 사용하여 문자열의 길이를 출력합니다.

13 int strleng(char *ch) 
14 {
15    int index;
16     for(index = 0; *(ch+index) != '\0'; index+ +);
17
18     return index; 
19 }
strleng 함수는 문자열의 길이를 계산하는 역할을 합니다.
for 루프는 문자열의 끝에 도달할 때까지 각 문자를 검사하고, 문자열의 길이를 나타내는 index 변수를 증가시킵니다.
포인터를 사용하여 문자열에 접근하고 있습니다. *(ch+index)는 현재 인덱스 위치에 있는 문자를 나타냅니다.
문자열의 끝은 널 문자('\0')로 표시되어 있으므로, 널 문자를 만날 때까지 계속해서 길이를 증가시킵니다.
함수는 최종적으로 계산된 길이를 반환합니다.
프로그램의 결과는 주어진 문자열 "c language and data structure"의 길이를 출력할 것입니다

========================================================

구조체
▪  서로 다른 자료형을 하나의 자료로 구조화한 자료형
▪  키워드 struct를 사용하여 정의
▪  struct 안의 각 구성 요소는 멤버라 부르며 중괄호({ }) 안에 정의
▪  마지막 중괄호( }) 다음에 반드시 세미콜론(;)을 넣어야 함.

========================================================

구조체를 정의할 때는 struct 키워드를 사용하고, 실제로 변수를 선언할 때는 구조체의 이름과 함께 변수 이름을 사용합니다. 예를 들어, struct Person { char name[20]; int age; };는 구조체를 정의하고, struct Person person1;은 구조체 변수를 선언합니다.
구조체 변수의 멤버에 접근할 때는 마침표(.)를 사용합니다. 예를 들어, person1.age는 Person 구조체 변수 person1의 age 멤버에 접근하는 것을 의미합니다.
구조체 배열을 만들 수 있고, 각 배열 요소에 접근할 때는 인덱스를 사용합니다. 또한, 구조체 포인터를 사용하여 동적으로 메모리를 할당하고 구조체를 조작할 수 있습니다.
구조체 안에 다른 구조체를 포함할 수 있습니다. 이를 통해 복잡한 데이터 구조를 표현할 수 있습니다.
컴파일러는 효율적인 메모리 사용을 위해 구조체 멤버들 간에 패딩을 추가할 수 있습니다. 이로 인해 구조체의 크기가 예상과 다를 수 있습니다.
비트 필드를 사용하여 구조체 멤버의 비트 수를 명시적으로 지정할 수 있습니다. 이를 통해 메모리를 절약하고 효율적으로 데이터를 저장할 수 있습니다.
함수에 구조체를 전달하거나 구조체를 반환하는 것이 가능합니다. 이를 통해 복잡한 데이터를 한 번에 전달하거나 반환할 수 있습니다.
구조체를 초기화할 때 중괄호를 사용하여 각 멤버에 값을 할당할 수 있습니다. 예를 들어, struct Person person1 = {"John", 25};는 구조체 변수를 초기화합니다.
유니온은 여러 멤버 중 하나만 사용되는 경우에 유용합니다. 모든 멤버가 같은 메모리 위치를 공유하며, 크기는 멤버 중 가장 큰 크기에 따라 결정됩니다.v

========================================================

#include <stdio.h>
02
03 struct list {
04     char name; 
05     char gender;
06     int age; 
07 };
08
09 int main(void) 
10 {
11     struct list st1 = {'T', 'M', 25};
12
13 printf("구조체 list의 크기는 %d이다.\n", sizeof(struct list));
14 printf("구조체 객체 st1의 크기는 %d이다.\n", sizeof(st1));
15
16     return 0; 
17 }

______________________________________________________________

03 struct list {
04     char name; 
05     char gender;
06     int age; 
07 };
struct list라는 구조체를 정의합니다. 이 구조체는 세 개의 멤버를 가지고 있습니다. 각 멤버는 이름(name), 성별(gender), 나이(age)를 나타내는 데이터 타입에 해당하는 변수입니다. 여기서는 문자(char)와 정수(int)를 사용했습니다.

09 int main(void) 
10 {
11     struct list st1 = {'T', 'M', 25};
main 함수가 시작됩니다. struct list 타입의 구조체 변수인 st1을 선언하고 초기화합니다. 이 구조체 변수는 이름이 'T', 성별이 'M', 나이가 25로 초기화되었습니다.

13 printf("구조체 list의 크기는 %d이다.\n", sizeof(struct list));
sizeof 연산자를 사용하여 struct list의 크기를 바이트 단위로 계산하고 출력합니다.

14 printf("구조체 객체 st1의 크기는 %d이다.\n", sizeof(st1));
이번에는 구조체 변수 st1의 크기를 계산하고 출력합니다.

========================================================

***  구조체명을 기록하지 않으면 변수를 선언 할 때마다 구조체의 정의 부분을 다시 작성해야 합니다.
